### 1. User Mode and Kernel Mode in Operating System

_CPU가 실행되는 두 가지 권한 수준(Privilege Level)을 의미_

> _**User Mode**_

- 정의
    - 애플리케이션 프로그램이 실행되는 모드
    - CPU는 제한된 권한만 가지며, 하드웨어 자원에 직접 접근 불가
- 특징
    - 사용자 프로세스는 커널 메모리에 접근할 수 없음
    - 잘못된 동작이 발생해도 OS 전체가 영향을 받지 않도록 격리
    - 하드웨어 제어나 시스템 콜은 직접 수행 불가
        - 반드시 커널 모드에 요청

> _**Kernel Mode**_

- 정의
    - 운영체제 커널이 동작하는 모드
    - CPU는 모든 명령을 수행할 수 있고, 모든 자원에 접근할 수 있음
- 특징
    - 메모리 관리, 프로세스 스케줄링, 파일 시스템 관리, 디바이스 드랑이버 제어 등 핵심 기능 수행
    - 잘못된 명령 실행 시 OS 전체가 치명적 오류 발생
    - 보안을 위해 일반 사용자 프로그램은 직접 진입 불가, System Call을 통해서만 가능

> _**User / Kernel Switching**_

- 전환 방법
    - 프로그램이 OS 기능을 요청할 때 시스템 콜을 발생시켜 CPU를 커널 모드로 전환
    - 예시
        - `read()`, `write()`, `fork()` 와 같은 시스템 콜은 사용자 모드에서 실행될 수 없으므로 커널 모드에서 처리

### 2. Register vs Memory

> _**Register**_

- 정의
    - 레지스터는 CPU 내부에 위치한 초고속 기억 장치
    - 명령어 실행 중 필요한 데이터를 임시로 저장
- 특징
    - CPU가 직접 접근할 수 있어 속도가 매우 빠름
    - 개수가 제한적, 용도에 따라 특수화된 레지스터 존재

> _**Memory**_

- 정의
    - 실행 중인 프로그램과 데이터를 저장하는 장치
    - CPU가 명령을 수행할 때 필요 데이터를 읽고 씀
- 특징
    - 속도는 레지스터보다 느리지만 저장 용량이 훨씬 큼
    - 프로그램 실행 시 디스크에서 코드와 데이터를 메모리로 적재한 후, CPU가 이를 실행
    - OS는 메모리를 효율적으로 관리하기 위해 가상 메모리 제공

### 3. User Stack

> _**정의**_

- User Stack은 프로세스의 사용자 공간에 존재하는 스택 메모리 영역
- 스택은 LIFO 구조를 가지며, 함수 호출과 반환, 지역 변수 관리에 사용

> _**역할**_

- 함수 호출 관리(Call Stack)
    - 함수가 호출될 때, 리턴 주소와 이전 스택 포인터가 저장됨
    - 함수가 끝나면 이 정보를 꺼내 원래 위치로 돌아감
- 지역 변수(Local Variable) 저장
    - 함수 내부에서 선언된 지역 변수들이 스택 프레임에 저장
- 매개변수(Parameter) 전달
    - 일부 아키텍처에서는 레지스터를 넘어가는 함수 인자를 스택에 저장하여 전달
- 임시 데이터 관리
    - 컴파일러가 중간 계산을 위해 사용하는 값도 스택에 저장될 수 있음

> _**동작 방식**_ 

- 스택은 스택 포인터 레지스터로 관리
- 함수 호출 시
    - 새로운 스택 프레임이 생성
    - 지역 변수와 함수 인자 저장
- 함수 반환 시
    - 스택 프레임이 해제, 이전 함수의 실행 상태로 복귀

> _**User Stack vs Kernel Stack**_ 

- User Stack
    - 사용자 모드에서 실행되는 코드가 사용하는 스택(프로세스별 존재)
- Kernel Stack
    - 시스템 콜이나 인터럽트 처리 시, 커널 모드에서 사용하는 별도의 스택
- 이유?
    - 보안을 위해 커널 모드와 사용자 모드가 스택을 분리해서 사용

### 4. System Call

> _**정의**_ 

- 사용자 프로그램(User mode)이 직접 수행할 수 없는 작업(e.g., I/O 접근, 프로세스 생성, 파일 관리 등)을 운영체제 커널(Kernel mode)에 요청하는 인터페이스
    - 즉, 유저 모드와 커널 모드를 연결하는 창구 역할

> _**시스템콜이 필요한 이유**_

- 보안: 사용자 프로그램이 임의로 하드웨어나 커널 메모리에 접근하면 시스템 전체가 위험 가능
- 추상화: 운영체제가 하드웨어 세부 동작을 숨기고, 사용자에게 단순한 API를 제공
- 안정성: 잘못된 접근을 운영체제가 제어

> _**동작 과정**_

1. 사용자 프로그램 호출
	- C 라이브러리(`glibc` 등)에서 제공하는 함수(`printf`, `open`, `read` 등)가 내부적으로 시스템 콜을 호출
2. 모드 전환
	- 프로그램이 트랩(trap, 소프트웨어 인터럽트)을 발생시켜 CPU를 유저 모드 → 커널 모드로 전환
3. 커널 처리
    - 커널의 시스템 콜 핸들러가 해당 요청을 처리 (예: 파일 읽기, 메모리 할당)
4. 결과 반환
    - 완료 후 커널은 결과 값을 레지스터에 넣어 커널 모드 → 유저 모드로 복귀

> _**주요 시스템 콜의 예시**_

- 프로세스 관리: `fork()`, `exec()`, `exit()`, `wait()`
- 파일 관리: `open()`, `read()`, `write()`, `close()`
- 디바이스 관리: `ioctl()`, `read()`, `write()`
- 통신: `socket()`, `send()`, `recv()`

### 5. File Descriptor

> _**정의**_

- OS에서 열린 파일을 식별하기 위해 사용하는 정수값
- 프로그램이 파일을 열면 운영체제 커널은 내부적으로 파일 객체를 생성
    - 이를 가리키는 작은 정수를 반환
    - 이 정수를 프로그램이 이후 read, write같은 시스템 콜에서 사용

> _**특징**_

- 정수 값으로 표현
    - UNIX 계열 시스템에서 프로세스가 시작될 때 기본적으로 할당되는 디스크립터
        - 0 : 표준 입력(Standard Input, stdin)
        - 1 : 표준 출력(Standard Output, stdout)
        - 2 : 표준 오류(Standard Error, stderr)
- 추상화된 인터페이스
    - 파일 뿐만 아니라 디바이스, 파이프, 소켓 등 다양한 I/O 자원을 동일한 방식으로 다룰 수 있음
    - 즉, "모든 것은 파일이다"라는 유닉스 철학을 구현
- 프로세스 단위로 관리
    - 각 프로세스마다 File Descriptor Table이 존재
    - 테이블의 엔트리에 파일 디스크립터 번호가 매핑되어 실제 커널 내부의 열린 파일 객체(Open File Table Entry)를 가리킴

> _**동작 과정**_ 

1. `fd = open("test.txt", O_RDWR);`
    - 커널이 `test.txt`를 열고, `File Descriptor Table`에 새로운 엔트리를 추가.
	- `open()`의 반환값으로 정수 `fd`가 제공됨.
2. `write(fd, buffer, size);`
	- `fd`를 인자로 넘기면, 커널이 File Descriptor Table을 참조해 해당 파일 객체를 찾아 처리.
3. `close(fd);`
	- 파일 디스크립터를 해제하여 자원을 반환

### 6. Cache

> _**정의**_

- CPU와 RAM 사이에 위치한 고속 임시 저장 장치
- CPU가 자주 접근하는 데이터나 명령어를 저장, 메모리 접근 시간을 줄이고 전체 성능 향상

> _**특징**_

- CPU 속도와 메모리 속도의 차이
    - CPU 클론 속도는 매우 빠른 반면, 메인 메모리 접근 속도는 상대적으로 느림
    - 만약 CPU가 직접 RAM에서만 데이터를 읽는다면 병목 발생
- 해결책
    - 캐시는 메모리에서 자주 쓰이는 데이터를 미리 가져와두고, CPU가 빠르게 접근할 수 있게 해줌

> _**동작 원리**_

- Spatial Locality
    - 특정 주소를 참조하면, 인접한 주소도 곧 참조된 가능성이 높음
    - 캐시는 해당 블록 전체를 가져옴
- Temporal Locality
    - 최근에 접근한 데이터는 가까운 미래에도 다시 접근될 가능성이 큼
    - 캐시에 최근 데이터를 보관
- Hit & Miss
    - Cache Hit : CPU가 요청한 데이터가 캐시에 존재 → 빠르게 반환
    - Cache Miss : 데이터가 캐시에 없음 → 메모리에서 가져와 캐시에 적재 후 CPU에 전달

> _**구조와 계층**_

- L1 Cache : CPU 코어 내부, 매우 작지만 초고속
- L2 Cache : CPU와 메모리 사이, 크기는 더 크고 L1보다 느림
- L3 Cache : 멀티코어 간 공유, L2보다 크지만 더 느림

> _**운영체제와 Cache**_

- 디스크 캐시 : 최근 접근한 디스크 블록을 메모리에 저장
- 버퍼 캐시 : 파일 시스템이 I/O 요청을 빠르게 처리하기 위해 사용
- 페이지 캐시 : 가상 메모리에서 자주 사용하는 페이지를 보관

> _**Cache Mapping**_

_메인 메모리 데이터를 캐시 메모리의 어느 위치에 저장할지 결정하는 규칙_  

1. 직접 매핑
    - 정해진 단 하나의 위치에만 저장될 수 있는 가장 간단한 캐시 매핑 방식
    > 메모리 주소를 tag, index, offset 세 부분으로 나누어 사용
    > [Tag | Index | Offset]

    - Tag
        - 메모리 블록들을 구분하기 위한 이름표
    - Index
        - 메모리 블록이 저장될 캐시 라인의 번호 지정
    - Offset
        - 캐시 라인 내에서 원하는 데이터가 어느 위치에 있는지 파악용

2. 완전 연관 매핑
    - 캐시의 비어있는 어떤 위치든지 자유롭게 저장될 수 있는 가장 유연한 방식
    > 메모리 주소를 두 부분으로 나눔
    > [Tag | Offset]
    
    - Tag
        - 메모리 블록을 구분하기 위한 이름표
    - Offset
        - 캐시 라인 내에 원하는 데이터가 어느 위치에 있는지 파악용

3. 세트 연관 매핑
    - 직접 매핑 + 완전 연관 매핑 = 하이브리드 방식
    > 메모리 주소를 tag, set index, offset 세 부분으로 나누어 사용
    > [Tag | Set Index | Offset]

    - Tag
        - 해당 세트 내에서 원하는 데이터가 맞는지 구분하기 위한 이름표
    - Set Index
        - 메모리 블록이 저장될 캐시의 세트 번호를 지정
    - Offset
        - 캐시 라인 내에 원하는 데이터가 어느 위치에 있는지 파악용

### 7. Atomic Operation

> _**정의**_

- 더 이상 나눌 수 없는 연산을 의미
- 실행 도중 다른 스레드나 인터럽트에 의해 중단되지 않으며, 완료되면 항상 전부 수행 or 전부 수행되지 않은 상태

> _**필요성**_

- 멀티스레드 환경에서 여러 스레드가 동시에 공유 자원에 접근
- 단순한 연산조차도 내부적으로 여러 단계로 나뉘기에 Race Condition이 발생할 수 있음
    - 이런한 상황에서 **일관성**과 **상호배제**를 보장

> _**특징**_

- Lock or Semaphore와 같은 고수준 동기화 기법의 기반으로 작용

### 8. RAX Register

> _**정의**_

- X86-64 CPU의 범용 레지스터 중 하나
- 원래 16비트에서는 AX, Accumulator Register의 역할
- 32비트에서는 EAX, 64비트에서는 RAX로 확장

> _**크기와 부분 접근**_

- `RAX`: 64비트 전체
- `EAX`: 하위 32비트
- `AX`: 하위 16비트
- `AH/AL`: AX의 상위/하위 8비트

```assembly
mov rax, 0x1122334455667788
mov eax, 0x99          ; rax = 0x0000000000000099
mov ax, 0xABCD         ; rax = 0x000000000000ABCD
mov al, 0xFF           ; rax = 0x000000000000ABFF
```

> _**주요 용도**_

- 산술 연산(Accumulator)
    - 고전적으로 곱셈 / 나눗셈 같은 연산에서 누산기로 사용
- 시스템 콜 인터페이스
    - 리눅스에서 `RAX`레지스터에 시스템 콜 번호를 넣고 `syscall` 명령어 실행
    - 결과값도 `RAX`에 반환

### 9. 32Bit OS vs 64Bit OS

> _**정의**_

- 32Bit OS
    - CPU의 레지스터 크기가 32비트, OS가 이를 기반으로 동작
    - Address Bus & Data Bus도 일반적으로 32비트에 맞게 설계
- 64Bit OS
    - CPU의 레지스터 크기가 64비트, OS가 64비트 명령 집합(ISA)을 활용하는 시스템
    - 더 큰 주소 공간과 확장된 연산을 지원

> _**특징 및 차이점**_

|구분|32Bit OS|64Bit OS|
|----|--------|--------|
|레지스터 크기|32Bit (EAX, EBX 등)|64Bit (RAX, RBX 등)|
|메모리 주소 공간|2^32, 최대 4GB|2^64, 최대 16EB|
|사용 가능한 RAM|최대 4GB|수 TB 이상도 지원 가능|
|데이터 처리 단위|한번에 4Byte 처리|한번에 8Byte 처리|
|포인터 크기|4Byte|8Byte|
|성능|메모리 사용이 적은 환경에서 효율적|대규모 메모리, 최신 CPU 환경에서 효율적|
|호환성|32Bit 응용 프로그램만 실행 가능|32, 64Bit 실행 가능|

### 10. Interrupt

> _**정의**_

- 프로세서가 현재 실행 중인 명령을 중단, 특정 사건(Event)를 처리하도록 제어를 전환하는 메커니즘
- CPU가 모든 장치를 직접 확인하는 대신, 하드웨어 / 소프트웨어가 CPU에 신호를 보내 필요한 처리를 요청

> _**Interrupt**_

- Hadware Interrupt
    - 키보드 입력, 디스크 I/O 완료, 네트워크 패킷 수신 등 장치에서 발생
- Software Interrupt
    - 프로그램 실행 중 발생하는 이벤트
- External Interrupt vs Internal Interrupt
    - 외부 : 하드웨어 장치에 의해 발생
    - 내부 : CPU 명령 실행 중 오류나 특별한 요청에 의해 발생

> _**동작 과정**_

1. 인터럽트 발생 (e.g., 디스크 I/O 완료)
2. CPU는 현재 실행 중이던 명령어 완료 후 인터럽트 벡터 테이블(Interrupt Vector Table, IVT)을 참조
3. 해당 인터럽트 번호에 맞는 인터럽트 서비스 루틴(ISR, Interrupt Service Routine)으로 제어를 전환
4. ISR 실행 → 필요한 작업 처리 (예: 데이터를 메모리에 복사)
5. 완료 후, CPU는 중단했던 지점으로 돌아와 명령 실행 재개

> _** 특징 / 장점**_

- 특징 / 장점
    - 비동기적 처리 : CPU가 I/O를 기다리지 않고 다른 일을 수행 가능
    - 효율성 향상 : Polling 방식 대비 성능이 좋아짐
    - 보호 기법 : 잘못된 접근(Page Fault)시 운영체제가 개입 가능

### 11. Segmentation Fault

> _**정의**_

- 프로세스가 허용되지 않은 메모리 영역에 접근했을 때 발생하는 오류
- 운영체제가 메모리를 보호하기 위해 제공하는 메모리 보호 기법 중 하나

> _**발생 원인**_

- 잘못된 포인터 접근
    - 초기화되지 않은 포인터 사용
    - NULL 포인터 역참조

```C
int *p = NULL;
*p = 10;        // segmentation fault 발생
```

- 배열 / 버퍼 경계 초과 : Out-of-Bounds Access
    - 배열 크기를 넘어선 인덱스 접근

```C
int arr[5];
arr[10] = 1;    // 잘못된 메모리 접근
```

- 읽기 전용 메모리에 쓰기
    - 문자열 상수 수정 시도

```C
char *str = "hello";
str[0] = "H"    // 읽기 전용 영역 수정 → Segmentation Fault
```

- 잘못된 스택 접근
    - 무한 재귀 호출로 스택 오버플로우 발생

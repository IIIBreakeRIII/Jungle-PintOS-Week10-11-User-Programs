### 1. User Mode and Kernel Mode in Operating System

_CPU가 실행되는 두 가지 권한 수준(Privilege Level)을 의미_

> _**User Mode**_

- 정의
    - 애플리케이션 프로그램이 실행되는 모드
    - CPU는 제한된 권한만 가지며, 하드웨어 자원에 직접 접근 불가
- 특징
    - 사용자 프로세스는 커널 메모리에 접근할 수 없음
    - 잘못된 동작이 발생해도 OS 전체가 영향을 받지 않도록 격리
    - 하드웨어 제어나 시스템 콜은 직접 수행 불가
        - 반드시 커널 모드에 요청

> _**Kernel Mode**_

- 정의
    - 운영체제 커널이 동작하는 모드
    - CPU는 모든 명령을 수행할 수 있고, 모든 자원에 접근할 수 있음
- 특징
    - 메모리 관리, 프로세스 스케줄링, 파일 시스템 관리, 디바이스 드랑이버 제어 등 핵심 기능 수행
    - 잘못된 명령 실행 시 OS 전체가 치명적 오류 발생
    - 보안을 위해 일반 사용자 프로그램은 직접 진입 불가, System Call을 통해서만 가능

> _**User / Kernel Switching**_

- 전환 방법
    - 프로그램이 OS 기능을 요청할 때 시스템 콜을 발생시켜 CPU를 커널 모드로 전환
    - 예시
        - `read()`, `write()`, `fork()` 와 같은 시스템 콜은 사용자 모드에서 실행될 수 없으므로 커널 모드에서 처리

### 2. Register vs Memory

> _**Register**_

- 정의
    - 레지스터는 CPU 내부에 위치한 초고속 기억 장치
    - 명령어 실행 중 필요한 데이터를 임시로 저장
- 특징
    - CPU가 직접 접근할 수 있어 속도가 매우 빠름
    - 개수가 제한적, 용도에 따라 특수화된 레지스터 존재

> _**Memory**_

- 정의
    - 실행 중인 프로그램과 데이터를 저장하는 장치
    - CPU가 명령을 수행할 때 필요 데이터를 읽고 씀
- 특징
    - 속도는 레지스터보다 느리지만 저장 용량이 훨씬 큼
    - 프로그램 실행 시 디스크에서 코드와 데이터를 메모리로 적재한 후, CPU가 이를 실행
    - OS는 메모리를 효율적으로 관리하기 위해 가상 메모리 제공

### 3. User Stack

> _**정의**_

- User Stack은 프로세스의 사용자 공간에 존재하는 스택 메모리 영역
- 스택은 LIFO 구조를 가지며, 함수 호출과 반환, 지역 변수 관리에 사용

> _**역할**_

- 함수 호출 관리(Call Stack)
    - 함수가 호출될 때, 리턴 주소와 이전 스택 포인터가 저장됨
    - 함수가 끝나면 이 정보를 꺼내 원래 위치로 돌아감
- 지역 변수(Local Variable) 저장
    - 함수 내부에서 선언된 지역 변수들이 스택 프레임에 저장
- 매개변수(Parameter) 전달
    - 일부 아키텍처에서는 레지스터를 넘어가는 함수 인자를 스택에 저장하여 전달
- 임시 데이터 관리
    - 컴파일러가 중간 계산을 위해 사용하는 값도 스택에 저장될 수 있음

> _**동작 방식**_ 

- 스택은 스택 포인터 레지스터로 관리
- 함수 호출 시
    - 새로운 스택 프레임이 생성
    - 지역 변수와 함수 인자 저장
- 함수 반환 시
    - 스택 프레임이 해제, 이전 함수의 실행 상태로 복귀

> _**User Stack vs Kernel Stack**_ 

- User Stack
    - 사용자 모드에서 실행되는 코드가 사용하는 스택(프로세스별 존재)
- Kernel Stack
    - 시스템 콜이나 인터럽트 처리 시, 커널 모드에서 사용하는 별도의 스택
- 이유?
    - 보안을 위해 커널 모드와 사용자 모드가 스택을 분리해서 사용

### 4. System Call

> _**정의**_ 

- 사용자 프로그램(User mode)이 직접 수행할 수 없는 작업(e.g., I/O 접근, 프로세스 생성, 파일 관리 등)을 운영체제 커널(Kernel mode)에 요청하는 인터페이스
    - 즉, 유저 모드와 커널 모드를 연결하는 창구 역할

> _**시스템콜이 필요한 이유**_

- 보안: 사용자 프로그램이 임의로 하드웨어나 커널 메모리에 접근하면 시스템 전체가 위험 가능
- 추상화: 운영체제가 하드웨어 세부 동작을 숨기고, 사용자에게 단순한 API를 제공
- 안정성: 잘못된 접근을 운영체제가 제어

> _**동작 과정**_

1. 사용자 프로그램 호출
	- C 라이브러리(`glibc` 등)에서 제공하는 함수(`printf`, `open`, `read` 등)가 내부적으로 시스템 콜을 호출
2. 모드 전환
	- 프로그램이 트랩(trap, 소프트웨어 인터럽트)을 발생시켜 CPU를 유저 모드 → 커널 모드로 전환
3. 커널 처리
    - 커널의 시스템 콜 핸들러가 해당 요청을 처리 (예: 파일 읽기, 메모리 할당)
4. 결과 반환
    - 완료 후 커널은 결과 값을 레지스터에 넣어 커널 모드 → 유저 모드로 복귀

> _**주요 시스템 콜의 예시**_

- 프로세스 관리: `fork()`, `exec()`, `exit()`, `wait()`
- 파일 관리: `open()`, `read()`, `write()`, `close()`
- 디바이스 관리: `ioctl()`, `read()`, `write()`
- 통신: `socket()`, `send()`, `recv()`
